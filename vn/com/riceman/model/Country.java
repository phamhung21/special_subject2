package vn.com.riceman.model;

import domainapp.basics.exceptions.ConstraintViolationException;
import domainapp.basics.model.meta.AttrRef;
import domainapp.basics.model.meta.DAssoc;
import domainapp.basics.model.meta.DAssoc.AssocEndType;
import domainapp.basics.model.meta.DAssoc.AssocType;
import domainapp.basics.model.meta.DAssoc.Associate;
import domainapp.basics.model.meta.DAttr;
import domainapp.basics.model.meta.DAttr.Type;
import domainapp.basics.model.meta.DClass;
import domainapp.basics.model.meta.DOpt;
import domainapp.basics.model.meta.MetaConstants;
import domainapp.basics.util.Tuple;

/**
 * A domain class whose objects are city names. This class is used as 
 * the <code>allowedValues</code> of the domain attributes of 
 * other domain classes (e.g. Student.address).  
 * 
 * <p>Method <code>toString</code> overrides <code>Object.toString</code> to 
 * return the string representation of a city name which is expected by 
 * the application. 
 * 
 * @author dmle
 *
 */
@DClass(schema="courseman")
public class Country {
  
	private static final String A_id = "id";
	@DAttr(name = A_id, id = true, auto = true, type = Type.String, length = 3, mutable = false, optional = false)
	private String id;
	private static int idCounter = 0;

  @DAttr(name="name",type=Type.String,length=20,optional=false)
  private String name;
  
  @DAttr(name="rice",type=Type.Domain,serialisable=false)
  @DAssoc(ascName="rice-has-country",role="country",
  ascType=AssocType.One2Many, endType=AssocEndType.One,
  associate=@Associate(type=Rice.class,cardMin=1,cardMax=MetaConstants.CARD_MORE,determinant=true))
  private Rice rice;

  // from object form: Student is not included 
  @DOpt(type=DOpt.Type.ObjectFormConstructor)
  @DOpt(type=DOpt.Type.RequiredConstructor)
  public Country(@AttrRef("name") String countryName) {
    this(null, countryName, null);
  }

  // from object form: Student is included
  @DOpt(type=DOpt.Type.ObjectFormConstructor)
  public Country(@AttrRef("name") String countryName, @AttrRef("rice") Rice rice) {
    this(null, countryName, rice);
  }

  // from data source
  @DOpt(type=DOpt.Type.DataSourceConstructor)
  public Country(@AttrRef("id") String id, @AttrRef("name") String cityName) {
    this(id, cityName, null);
  }
  
  // based constructor (used by others)
  private Country(String id, String countryName, Rice rice) {
    this.id = nextID(id);
    this.name = countryName;
    this.rice = rice;
  }
  
  
  @Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		return result;
	}
  
  @Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Country other = (Country) obj;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		return true;
	}
  
  
  private String nextID(String id) throws ConstraintViolationException {
		if (id == null) {
			// generate a new id
			idCounter++;
			if (idCounter >= 10) {
				return "C" + idCounter;
			} else {
				return "C0" + idCounter;
			}
		} else {
			// update id
			int num;
			try {
				num = Integer.parseInt(id.substring(1));
			} catch (RuntimeException e) {
				throw new ConstraintViolationException(ConstraintViolationException.Code.INVALID_VALUE, e,
						new Object[] { id });
			}

			if (num > idCounter) {
				idCounter = num;
			}

			return id;
		}
	}

  /**
   * @requires 
   *  minVal != null /\ maxVal != null
   * @effects 
   *  update the auto-generated value of attribute <tt>attrib</tt>, specified for <tt>derivingValue</tt>, using <tt>minVal, maxVal</tt>
   */
  @DOpt(type = DOpt.Type.AutoAttributeValueSynchroniser)
	public static void updateAutoGeneratedValue(DAttr attrib, Tuple derivingValue, Object minVal, Object maxVal)
			throws ConstraintViolationException {

		if (minVal != null && maxVal != null) {
			String maxId = (String) maxVal;
			try {
				int maxIdNum = Integer.parseInt(maxId.substring(1));

				if (maxIdNum > idCounter) // extra check
					idCounter = maxIdNum;

			} catch (RuntimeException e) {
				throw new ConstraintViolationException(ConstraintViolationException.Code.INVALID_VALUE, e,
						new Object[] { maxId });
			}
		}
	}
  
  public String getId() {
    return id;
  }
  
  public String getName() {
    return name;
  }
  
  public void setName(String name) {
    this.name = name;
  }

  public Rice getRice() {
    return rice;
  }

  @DOpt(type=DOpt.Type.LinkAdderNew)
  public void setNewRice(Rice rice) {
    this.rice = rice;
    // do other updates here (if needed)
  }

  public void setRice(Rice rice) {
    this.rice = rice;
  }

  @Override
  public String toString() {
    return name;
  }
}
